
# Course Philosophy (Quietly Enforced)

- **Concepts before tools**
- **Constraints before solutions**
- **Failures before optimizations**
- **Trade-offs everywhere**

No jumping to Kafka before understanding queues. No microservices before modular monoliths. No magic.

---

## Course Structure

### [Phase 0 — How to Think in Systems (Foundation)](phase-0-foundation.md)
Most courses skip this. They shouldn't.

### [Phase 1 — Core Building Blocks](phase-1-building-blocks.md)
These are the atoms. Everything later is recombination.

### [Phase 2 — Scaling Reads and Writes](phase-2-scaling.md)
Now scale hurts. Good.

### [Phase 3 — Distributed System Realities](phase-3-distributed-systems.md)
This is where illusions die.

### [Phase 4 — Asynchronous & Event-Driven Design](phase-4-async-events.md)
Systems breathe when decoupled.

### [Phase 5 — Reliability & Failure Engineering](phase-5-reliability.md)
This is senior-level thinking.

### [Phase 6 — Security & Data Safety (Design Level)](phase-6-security.md)
Not implementation—architecture.

### [Phase 7 — Observability & Operations](phase-7-observability.md)
A system you can't see is already broken.

### [Phase 8 — Case Studies (Synthesis)](phase-8-case-studies.md)
Now we combine everything.

---

## Learning Outcomes by Phase

- **Phase 0**: Learner stops panicking when given vague problems
- **Phase 1**: Learner understands why systems slow down
- **Phase 2**: Learner can design for traffic, not hope
- **Phase 3**: Learner stops believing in "perfect systems"
- **Phase 4**: Learner designs systems that absorb spikes gracefully
- **Phase 5**: Learner designs for bad days, not demos
- **Phase 6**: Learner stops treating security as an afterthought
- **Phase 7**: Learner can run systems, not just design them
- **Phase 8**: Learner can synthesize all concepts into real-world solutions